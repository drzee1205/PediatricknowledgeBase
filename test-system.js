// Comprehensive System Test for NelsonGPT Backend
import { supabaseServiceBackend } from './src/lib/supabase';\nimport { mistralService } from './src/lib/mistral-service';\nimport { geminiService } from './src/lib/gemini-service';\nimport { embeddingService } from './src/lib/embeddings';\nimport { vectorDatabaseService } from './src/lib/vector-database';\nimport { enhancedRAGPipeline } from './src/lib/rag-pipeline';\nimport { securityService } from './src/lib/security';\n\ninterface TestResult {\n  service: string;\n  passed: boolean;\n  message: string;\n  details?: any;\n  error?: string;\n}\n\nclass NelsonGPTSystemTester {\n  private results: TestResult[] = [];\n\n  /**\n   * Run comprehensive system tests\n   */\n  async runAllTests(): Promise<{\n    totalTests: number;\n    passed: number;\n    failed: number;\n    results: TestResult[];\n    summary: string;\n  }> {\n    console.log('ðŸ” Starting NelsonGPT System Tests...');\n    \n    // Test each service\n    await this.testSupabaseConnection();\n    await this.testMistralService();\n    await this.testGeminiService();\n    await this.testEmbeddingService();\n    await this.testSecurityService();\n    await this.testRAGPipeline();\n    await this.testMedicalQueryFlow();\n    \n    // Calculate results\n    const passed = this.results.filter(r => r.passed).length;\n    const failed = this.results.filter(r => !r.passed).length;\n    const totalTests = this.results.length;\n    \n    const summary = this.generateSummary(passed, failed, totalTests);\n    \n    return {\n      totalTests,\n      passed,\n      failed,\n      results: this.results,\n      summary\n    };\n  }\n\n  /**\n   * Test Supabase database connection\n   */\n  private async testSupabaseConnection(): Promise<void> {\n    console.log('Testing Supabase connection...');\n    \n    try {\n      const result = await supabaseServiceBackend.testConnection();\n      \n      this.results.push({\n        service: 'Supabase Database',\n        passed: result.success,\n        message: result.message,\n        details: {\n          url: process.env.NEXT_PUBLIC_SUPABASE_URL,\n          hasServiceKey: !!process.env.SUPABASE_SERVICE_KEY\n        }\n      });\n    } catch (error) {\n      this.results.push({\n        service: 'Supabase Database',\n        passed: false,\n        message: 'Connection test failed',\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n    }\n  }\n\n  /**\n   * Test Mistral AI service\n   */\n  private async testMistralService(): Promise<void> {\n    console.log('Testing Mistral AI service...');\n    \n    try {\n      const result = await mistralService.testService();\n      \n      this.results.push({\n        service: 'Mistral AI',\n        passed: result.success,\n        message: result.message,\n        details: {\n          hasApiKey: !!process.env.MISTRAL_API_KEY,\n          model: process.env.MISTRAL_MODEL || 'mistral-medium',\n          response: result.response?.substring(0, 100) + '...'\n        }\n      });\n    } catch (error) {\n      this.results.push({\n        service: 'Mistral AI',\n        passed: false,\n        message: 'Service test failed',\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n    }\n  }\n\n  /**\n   * Test Gemini AI service\n   */\n  private async testGeminiService(): Promise<void> {\n    console.log('Testing Gemini AI service...');\n    \n    try {\n      const result = await geminiService.testService();\n      \n      this.results.push({\n        service: 'Gemini AI',\n        passed: result.success,\n        message: result.message,\n        details: {\n          hasApiKey: !!process.env.GEMINI_API_KEY,\n          model: process.env.GEMINI_MODEL || 'gemini-pro',\n          response: result.response?.substring(0, 100) + '...'\n        }\n      });\n    } catch (error) {\n      this.results.push({\n        service: 'Gemini AI',\n        passed: false,\n        message: 'Service test failed',\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n    }\n  }\n\n  /**\n   * Test HuggingFace embedding service\n   */\n  private async testEmbeddingService(): Promise<void> {\n    console.log('Testing HuggingFace embedding service...');\n    \n    try {\n      const result = await embeddingService.testService();\n      \n      this.results.push({\n        service: 'HuggingFace Embeddings',\n        passed: result.success,\n        message: result.message,\n        details: {\n          hasApiKey: !!process.env.HUGGINGFACE_API_KEY,\n          model: process.env.EMBEDDING_MODEL || 'sentence-transformers/all-MiniLM-L6-v2',\n          embeddingDimension: result.embedding?.length || 0\n        }\n      });\n    } catch (error) {\n      this.results.push({\n        service: 'HuggingFace Embeddings',\n        passed: false,\n        message: 'Service test failed',\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n    }\n  }\n\n  /**\n   * Test security service\n   */\n  private async testSecurityService(): Promise<void> {\n    console.log('Testing security service...');\n    \n    try {\n      const validation = securityService.validateSecurityConfig();\n      \n      // Test input validation\n      const inputTest = securityService.validateMedicalInput({\n        query: 'What are the symptoms of pediatric asthma?',\n        sessionId: 'test-session-123'\n      });\n      \n      const passed = validation.isValid && inputTest.isValid;\n      \n      this.results.push({\n        service: 'Security Service',\n        passed,\n        message: passed ? 'Security configuration valid' : 'Security issues detected',\n        details: {\n          configErrors: validation.errors,\n          configWarnings: validation.warnings,\n          inputValidation: inputTest.isValid,\n          hasEncryptionKey: !!process.env.ENCRYPTION_KEY\n        }\n      });\n    } catch (error) {\n      this.results.push({\n        service: 'Security Service',\n        passed: false,\n        message: 'Security test failed',\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n    }\n  }\n\n  /**\n   * Test RAG pipeline\n   */\n  private async testRAGPipeline(): Promise<void> {\n    console.log('Testing enhanced RAG pipeline...');\n    \n    try {\n      const testResult = await enhancedRAGPipeline.testPipeline();\n      \n      this.results.push({\n        service: 'Enhanced RAG Pipeline',\n        passed: testResult.success,\n        message: testResult.message,\n        details: {\n          performance: testResult.performance,\n          documentsRetrieved: testResult.performance?.documentsRetrieved || 0,\n          responseTime: testResult.performance?.responseTime || 0,\n          confidence: testResult.performance?.confidenceScore || 0\n        }\n      });\n    } catch (error) {\n      this.results.push({\n        service: 'Enhanced RAG Pipeline',\n        passed: false,\n        message: 'RAG pipeline test failed',\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n    }\n  }\n\n  /**\n   * Test complete medical query flow\n   */\n  private async testMedicalQueryFlow(): Promise<void> {\n    console.log('Testing complete medical query flow...');\n    \n    try {\n      // Test a simple medical query\n      const testQuery = 'What is the recommended treatment for pediatric fever in a 3-year-old?';\n      \n      // This would use the enhanced workflow, but for testing we'll use a simpler approach\n      const ragResult = await enhancedRAGPipeline.execute(testQuery, {\n        patientAge: 'child',\n        urgencyLevel: 'medium',\n        queryType: 'treatment'\n      });\n      \n      const passed = ragResult.confidence > 0.3 && ragResult.primaryResponse.length > 100;\n      \n      this.results.push({\n        service: 'Medical Query Flow',\n        passed,\n        message: passed ? 'Medical query flow working correctly' : 'Medical query flow has issues',\n        details: {\n          query: testQuery,\n          confidence: ragResult.confidence,\n          responseLength: ragResult.primaryResponse.length,\n          processingTime: ragResult.processingTime,\n          documentsUsed: ragResult.metadata.documentCount,\n          validationPassed: ragResult.metadata.medicalValidation.passed\n        }\n      });\n    } catch (error) {\n      this.results.push({\n        service: 'Medical Query Flow',\n        passed: false,\n        message: 'Medical query flow test failed',\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n    }\n  }\n\n  /**\n   * Generate test summary\n   */\n  private generateSummary(passed: number, failed: number, total: number): string {\n    const passRate = ((passed / total) * 100).toFixed(1);\n    \n    let summary = `ðŸ” NelsonGPT System Test Results\\n`;\n    summary += `${'='.repeat(50)}\\n`;\n    summary += `Total Tests: ${total}\\n`;\n    summary += `âœ… Passed: ${passed}\\n`;\n    summary += `âŒ Failed: ${failed}\\n`;\n    summary += `ðŸ“Š Pass Rate: ${passRate}%\\n\\n`;\n    \n    if (failed === 0) {\n      summary += `ðŸŽ‰ All tests passed! Your NelsonGPT backend is ready for use.\\n`;\n    } else {\n      summary += `âš ï¸  Some tests failed. Please check the detailed results below.\\n`;\n    }\n    \n    summary += `\\nDetailed Results:\\n`;\n    summary += `${'='.repeat(50)}\\n`;\n    \n    this.results.forEach((result, index) => {\n      const status = result.passed ? 'âœ…' : 'âŒ';\n      summary += `${index + 1}. ${status} ${result.service}: ${result.message}\\n`;\n      \n      if (!result.passed && result.error) {\n        summary += `   Error: ${result.error}\\n`;\n      }\n      \n      if (result.details) {\n        summary += `   Details: ${JSON.stringify(result.details, null, 2)}\\n`;\n      }\n      \n      summary += `\\n`;\n    });\n    \n    return summary;\n  }\n\n  /**\n   * Get recommendations based on test results\n   */\n  getRecommendations(): string[] {\n    const recommendations: string[] = [];\n    \n    this.results.forEach(result => {\n      if (!result.passed) {\n        switch (result.service) {\n          case 'Supabase Database':\n            recommendations.push('Check Supabase URL and service key configuration');\n            break;\n          case 'Mistral AI':\n            recommendations.push('Verify Mistral API key and check network connectivity');\n            break;\n          case 'Gemini AI':\n            recommendations.push('Verify Gemini API key and check quota limits');\n            break;\n          case 'HuggingFace Embeddings':\n            recommendations.push('Verify HuggingFace API key and model availability');\n            break;\n          case 'Security Service':\n            recommendations.push('Configure missing environment variables for security');\n            break;\n          case 'Enhanced RAG Pipeline':\n            recommendations.push('Ensure database has medical documents and embeddings');\n            break;\n          case 'Medical Query Flow':\n            recommendations.push('Check if Nelson Textbook data is properly loaded');\n            break;\n        }\n      }\n    });\n    \n    return recommendations;\n  }\n}\n\n// Export for use\nexport const systemTester = new NelsonGPTSystemTester();\n\n// Run tests if this file is executed directly\nif (require.main === module) {\n  systemTester.runAllTests().then(results => {\n    console.log(results.summary);\n    \n    const recommendations = systemTester.getRecommendations();\n    if (recommendations.length > 0) {\n      console.log('\\nðŸ”§ Recommendations:');\n      recommendations.forEach((rec, index) => {\n        console.log(`${index + 1}. ${rec}`);\n      });\n    }\n    \n    process.exit(results.failed > 0 ? 1 : 0);\n  }).catch(error => {\n    console.error('Test execution failed:', error);\n    process.exit(1);\n  });\n}